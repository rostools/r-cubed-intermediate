# Save time, don't repeat yourself {#dry}

![](https://img.shields.io/badge/document%20status-in%20progress-red?style=flat-square)

```{r setup, include=FALSE}
library(here)
library(fs)
library(dplyr)
library(purrr)
```

```{r, eval=TRUE, child="resources/preamble.Rmd"}
```

Here we will cover the second block, "*Workflow*" in Figure \@ref(fig:diagram-overview-2).

```{r diagram-overview-2, fig.cap="Section of the overall workflow we will be covering.", echo=FALSE}
diagram_overview(2)
```

And your folder and file structure should look like:

```
LearnR3
├── data/
│   └── README.md
├── data-raw/
│   ├── mmash-data.zip
│   ├── mmash/
│   │  ├── user_1
│   │  ├── ...
│   │  └── user_22
│   └── mmash.R
├── doc/
│   ├── README.md
│   └── lesson.Rmd
├── R/
│   └── README.md
├── .Rbuildignore
├── .gitignore
├── DESCRIPTION
├── LearnR3.Rproj
└── README.md
```

## Learning objectives

1. Learn what functions are in R, how to make and use them.
1. Learn about functional programming, vectorization, and functionals,
and how to use them to get more done with less code and less time.
1. Learn a workflow of using R Markdown and `devtools::load_all()` (or
"Ctrl-Shift-L" in RStudio) as a tool and process for developing functions
that can be automatically loaded in for later and easy use.
1. Learn what R package dependency management is and how it can simplify your
data analysis work.
1. Continue practicing Git version control to manage changes to your files.

- Moving functions into own R file
    - Then either sourcing or load_all (maybe not get into that for them)
    
## The basics of a function

```{r}
sd
```

As mentioned before, all actions in R are functions. For instance, the `+` is a
function, `mean()` is a function, `[]` is a function, and so on. So creating
your functions can make doing your work easier and more efficient. Making
functions always has a basic structure of:

1. Giving a name to the function (e.g. `mean`).
2. Starting the function call using `function()`, assigning it to the name with
`<-`. This tells R that the name is a function object.
3. Optionally providing arguments to give to the function call, for instance
`function(arg1, arg2, arg3)`. 
4. Filling out the body of the function, with the arguments (if any) contained
inside, that does some action.
5. Optionally, but strongly encouraged, use `return` to indicate what you want 
the function to output.

While there is no minimum or maximum number of arguments you can provide for a
function (e.g. you could have zero or dozens of arguments), its good practice
for yourself and for others if you have as few arguments as possible to get
the job done.

So, the structure is:

```{r function-structure, eval=FALSE}
name <- function(arg1, arg2) {
    # body of function
    ... code ....
    return(output)
}
```

... and an example:

```{r create-add-function}
add_nums <- function(num1, num2) {
    added <- num1 + num2
    return(added)
}
```

You can use the new function by running the above code and writing out your new 
function, with arguments to give it.

```{r call-function}
add_nums(1, 2)
```

The function name is fairly good... `add_nums` can be read as "add numbers".
It's also good practice to add some formal documentation to the function. Use
the "Insert Roxygen Skeleton" in the "Code" menu list (or by typing
`Ctrl-Shift-Alt-R`) and you can add template documentation right above the
function. It looks like:

```{r roxygen-docs-1}
#' Title
#'
#' @param num1 
#' @param num2 
#'
#' @return
#' @export
#'
#' @examples
add_nums <- function(num1, num2) {
    added <- num1 + num2
    return(added)
}
```

In the `Title` area, this is where you type out a brief sentence or several words 
that describe the function. Creating a new paragraph below this line allows you 
to add a more detailed description. The other items are:

- `@param num` lines are to describe what each argument is for.
- `@return` describes what output the function provides. Is it a data.frame? A plot? 
What else does the output give?
- `@export` tells R that this function should be accessible to the user of your
package. Delete it for non-package functions.
- `@examples` lines below this are used to show examples of how to use the function.
Very useful when making packages, but not really in this case.

```{r roxygen-docs-2}
#' Add two numbers together.
#'
#' This is just an example function to show how to create one.
#'
#' @param num1 A number here.
#' @param num2 A number here.
#'
#' @return Returns the sum of the two numbers.
#'
add_nums <- function(num1, num2) {
    added <- num1 + num2
    return(added)
}
```

## Making a function for vroom

Now that we have a basic understanding of what a function looks like, let's
apply it to something we're doing right now: Importing our data.

Making functions is a series of steps:

1. Write code that works and does what you want.
1. Enclose it as a function with `function() { ... }`, with an appropriate and
descriptive name.
1. Create arguments in the function call (`function(arg1, arg2)`) with appropriate
and descriptive names, then replace the code with the argument names where 
appropriate. 
1. Rename any objects created to be more generic and include the `return()`
function at the end to indicate what the function will output.
1. Run the function and check that it works.
1. Add the roxygen2 documentation tags (with "Ctrl-Alt-Shift-R" or "Code -> Insert
Roxygen Skeleton" menu item while the cursor is in the function).

So, step one. Here is the code we want as a function:

```{r function-creation-step-1, eval=FALSE}
user_1_info_data <- vroom(
    user_1_info_file,
    col_select = -1,
    col_types = cols(
        Gender = col_character(),
        Weight = col_double(),
        Height = col_double(),
        Age = col_double()
    )
)
```

Next we wrap it in the function call and give it an appropriate name. In this case,
`import_user_info` is descriptive and meaningful. Make sure to style it correctly
with "Ctrl-Shift-A".

```{r function-creation-step-2, eval=FALSE}
import_user_info <- function() {
    user_1_info_data <- vroom(
        user_1_info_file,
        col_select = -1,
        col_types = cols(
            Gender = col_character(),
            Weight = col_double(),
            Height = col_double(),
            Age = col_double()
        )
    )
}
```

Then, we add arguments in the function and replace within the code. Here, we
have only one thing that we would change: The file path to the dataset.
So, a good name might be `file_path`.

```{r function-creation-step-3, eval=FALSE}
import_user_info <- function(file_path) {
    user_1_info_data <- vroom(
        file_path,
        col_select = -1,
        col_types = cols(
            Gender = col_character(),
            Weight = col_double(),
            Height = col_double(),
            Age = col_double()
        )
    )
}
```

Then we clean things up by renaming `user_1_info_data` since we would like to
also import more than just `user_1`. A nice object name would be `info_data`. 
Add the return function at the end with the object you want your function to
output.

```{r function-creation-step-4, eval=FALSE}
import_user_info <- function(file_path) {
    info_data <- vroom(
        file_path,
        col_select = -1,
        col_types = cols(
            Gender = col_character(),
            Weight = col_double(),
            Height = col_double(),
            Age = col_double()
        )
    )
    return(info_data)
}
```

Great! Now we need to test it out. Let's try on two datasets, `user_1` and `user_2`.

```{r function-creation-step-5}
import_user_info <- function(file_path) {
    info_data <- vroom(
        file_path,
        col_select = -1,
        col_types = cols(
            Gender = col_character(),
            Weight = col_double(),
            Height = col_double(),
            Age = col_double()
        )
    )
    return(info_data)
}

import_user_info(here::here("data-raw/mmash/user_1/user_info.csv"))
import_user_info(here::here("data-raw/mmash/user_2/user_info.csv"))
```

Awesome! It works. The final stage is adding the Roxygen documentation.

```{r function-creation-step-6}
#' Import MMASH user info data file.
#'
#' @param file_path Path to user info data file.
#'
#' @return Outputs a dataframe.
#'
import_user_info <- function(file_path) {
    info_data <- vroom(
        file_path,
        col_select = -1,
        col_types = cols(
            Gender = col_character(),
            Weight = col_double(),
            Height = col_double(),
            Age = col_double()
        )
    )
    return(info_data)
}
```

A massive advantage of using functions is that if you want to make a change to all
your code, you can very easily do it in the R function and it will change all 
your other code too!


## Exercise: Repeat with the saliva data

Time: 15 min

Now do this for the saliva importing code.

## R/ folder, load_all, and developing functions

- package dependency
    - use_package
    - ::
    
A good practice to use after you've created your function is to explicitly indicate 
which functions come from which package, since you shouldn't use `library` calls
in your function. We do this by using the `packagename::function_name` format 
(you don't need to do this for base R functions). Plus, let's add some
documentation! (`Ctrl-Alt-Shift-R`).

```{r explicit-function-call}
#' Calculate mean and standard deviation by a grouping variable.
#'
#' @param .dataset The dataset
#' @param .group_variable Variable to group by
#'
#' @return Output a data frame.
#'
mean_sd_by_group <- function(.dataset, .groupvar) {
    stopifnot(is.character(.groupvar))
    by_group_output <- .dataset %>% 
        dplyr::select_at(dplyr::vars(.groupvar, BMI, 
                                     TotChol, Pulse, BPSysAve, BPDiaAve)) %>% 
        tidyr::gather(Measurement, Value, -.groupvar) %>% 
        na.omit() %>% 
        dplyr::group_by_at(dplyr::vars(.groupvar, Measurement)) %>% 
        dplyr::summarise(Mean = round(mean(Value), 2),
                  SD = round(sd(Value), 2),
                  MeanSD = stringr::str_c(Mean, " (", SD, ")")) %>% 
        dplyr::select(-Mean, -SD) %>% 
        tidyr::spread(.groupvar, MeanSD)
    return(by_group_output)
}
```


## Exercise

Do this for the rest of the code you worked on previously that imported the 
`RR.csv` and `Actigraph.csv` data.

## Functional programming


- functional programming: functionals and vectorization
    - multiple files with map (for now ignoring that vroom can do it fine.)
    
        - Show basic usage with paste and numbers, etc.
        
        - Any time you think you would use a for loop, use this.
        
    - Real examples: 
        - my webscraping of the DST etc
        - Running multiple models
        
    - purrr
    - Why purrr vs *apply functions?
        - Consistency, expectation, documentation, design.
    - Show importing one vs many
        - Use fs to list multiple files
        - Talk about filesystem


Include this here?

it's better to try to reduce your repetition (i.e. don't repeat
yourself, DRY). Here we will get into iterations and using "[functional] programming"
via the `map` function from the [purrr] package. Functional programming is a way 
of making use of vectors and [vectorisation] to "loop" over things (rather than
use `for` loops). There are several reasons why you should avoid `for` loops in
R.

1. They are computationally very slow and easily use a lot of RAM memory.
1. They are difficult to read and debug.
1. They aren't very *expressive*, meaning they don't state a higher "purpose",
just that they loop over something.

[purrr]: https://purrr.tidyverse.org/
[vectorisation]: https://bookdown.org/rdpeng/rprogdatascience/vectorized-operations.html
[functional]: https://adv-r.had.co.nz/Functionals.html

But functionals, like `map` and most functions inside purrr (or base R functions
like `lapply`, `sapply`) let you ignore the tiny details and focus on doing your
intent. You *intend* to `sum` a vector of numbers, not loop over each number and
add to the total (as you would in a `for` loop).

For the example, let's say we want to calculate the mean and SD for several
categorical variables. We can use `map` to easily do this, by giving it a vector
of variables and providing the function to apply to each:

```{r map-on-wrangling}
map(c("SurveyYr", "Diabetes", "Gender"),
    # the ~ tells map the next code is all together as one argument
    # .x says to insert the value from the first argument of map (Diabetes, etc)
    ~mean_sd_by_group(NHANES, .x))
```

It seems deceptively simple but there is a massive amount of power from doing this
sort of coding. Let's try with the plots.

```{r map-on-plots}
map(c("Diabetes", "Education", "HomeOwn"),
    ~plot_scatter_by_group(NHANES, "Height", "Weight", .x))
```

What if we want to provide two things at once? We can use `map2` for that! (Note,
the two arguments should be the same length.)

```{r map2-on-plots}
map2(c("TotChol", "Pulse"),
    c("Diabetes", "Education"),
    # .y is for the second argument of map
    ~plot_scatter_by_group(NHANES, "Height", .x, .y))
```

If you want to do all combinations of two vectors, use the purrr function `cross_df()`
to create a data.frame of the combinations. Note that, like most purrr functions,
it takes a list as input.

```{r all-combinations}
all_combinations <- cross_df(list(
    xvar = c("TotChol", "Pulse"),
    groupvar = c("Diabetes", "Education")
    ))
all_combinations
```

```{r plot-all-combinations, eval=FALSE}
map2(all_combinations$xvar, all_combinations$groupvar,
    ~plot_scatter_by_group(NHANES, "BMI", .x, .y))
```


```{r}
library(vroom)
library(here)
library(dplyr)
user_1_rr_file <- here("data-raw/mmash/user_1/RR.csv")
user_1_rr_data <- vroom(
    user_1_rr_file,
    col_select = -1,
    col_types = cols(
        ibi_s = col_double(),
        day = col_double(),
        # Converts to seconds
        time = col_time(format = "")
    )
) %>% 
    rename(inter_beat_interval_seconds = ibi_s)

library(ggplot2)
ggplot(user_1_rr_data, aes(x = time, y = inter_beat_interval_seconds)) +
    geom_line() +
    facet_grid(rows = vars(day))

user_1_rr_data %>% 
    group_by(day) %>% 
    summarize(across(inter_beat_interval_seconds, 
                     list(mean = mean, min = min, max = max)))

user_1_rr_data %>% 
    group_by(day) %>% 
    # functional programming
    summarize(across(inter_beat_interval_seconds, 
                     list(mean = mean, min = min, max = max, sd = sd)))


```


- functionals
- load all datasets
- 

Day 1 afternoon (13:15, end at 17:30 --- ~4.25 hrs, with one big break, two small ones during exercise):

- functional programming
    - Q: Any one use for loops? Instead you should use functionals like map (R's
    strength is this)
    - talk about and introduce here
        - weaknesses of loops, strengths of functionals
        - naive approach to find mean (or do simple transformations) of each
        column is to do for loop with mean of each column in dataset
        - Images inspired from advanced R
            - Use diagrammer graphviz?
    - This section prepares for the functional programming session


Using map is really useful when importing raw data that is in a standard form
and structure. Combined with the [fs] package (fs for filesystem), this is very
powerful. To show how to do it, let's first export NHANES into the `data/` folder.

[fs]: https://fs.r-lib.org/

Then we can use the `dir_ls()` (for directory list) from fs combined with the 
`regexp` (for regular expression) argument to show all files that have
nhanes in the name, have anything in the middle (`.*`), and end with (`$`) csv.

Then we can import all at once using `map_dfr` (for map and convert to a `df`
data.frame, stacking by `r` row):

## Misc

Some best practices

Here are a few tips for being efficient. Also check out the resources at the 
bottom for more places to learn about being efficient.

- Aggressively keep your code as simple and concise as you can. The less code
you have to write, debug, and maintain, the better. If you repeat code, stop and
think how to not repeat it. You will save time in the end by taking time to think
and plan.
- Try to always think in terms of wrangling data as data.frames. There is a lot
of power and utility from structure most things as data.frames. (e.g. "how can I
get the dataframe to the form I need to make a figure?")
- Keep learning. Keep reading books and help documentation. Keep taking courses
and workshops. And start teaching R to others! *hint hint* :wink: Seriously, it's
a great way for you to learn as it challenges you to know what you are talking 
about and teaching!
- When encountering a difficult problem, think about how to solve it, then try
to find R packages or functions that do your problem for you. You may hear some
poeple say "oh, don't bother with R packages, do everything in base R"... don't 
listen to them. Do you build a computer from scratch everytime you want to do
any type of work? Or a car when you want to drive somewhere? No, you don't. Make
use of other people's hard work to make tools that simplify your life.
- Use a [style guide] and create descriptive object names. Follow the [principles of tidy tools]
when creating functions and code.
- Split up your analyses steps into individual files (e.g. "model" file, "plot"
file). Then `source` those files as needed or save the output in `data/` to use 
it in other files.
- Try not to have R scripts be too long (e.g. more than 500 lines of code). Keep
script sizes as small as necessary and as specific as possible (have a single purpose).
A script should have an end goal.

[style guide]: https://style.tidyverse.org/

`r '-->'`
